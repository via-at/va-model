<link rel="import" href="../polymerfire/firebase-database-behavior.html">

<script>
  VA.Transaction = function Transaction(appName) {
    var app = appName ? firebase.app(appName) : firebase.app();
    this._appName = appName;
    this._db = app ? app.database() : null;
    this._transactions = {};
  };
  
  VA.Transaction.prototype.appName = function () {
    return this._appName;
  };
  
  VA.Transaction.prototype.push = function (path, value) {
    this._transactions[path] = value;
  };
  
  VA.Transaction.prototype.list = function () {
    return this._transactions;
  };
  
  VA.Transaction.prototype.merge = function (transaction) {
    if (transaction instanceof VA.Transaction) {
      if (this._appName === transaction.appName()) {
        var lists = transaction.list();
        for (var path in lists) {
          this._transactions[path] = lists[path];
        }
      } else {
        console.warn("Source app name '" + transaction.appName() + "' and destination app name '" + this._appName +"' are difference.");
      }
    }
  };
  
  VA.Transaction.prototype.update = function () {
    this._db.ref.root.update(this._transactions);
  };
  
  VA.ModelBehaviorImpl = {
    
    properties: {
      
      key: {
        type: String,
        observer: '_keyChanged'
      },
      
      path: {
        type: String
      },
      
      data: {
        type: Object
      },
      
      preData: {
        type: Object
      },
      
      parents: {
        type: Object
      },
      
      relationships: {
        type: Object
      },
      
      assocKeys: {
        notify: true,
        value: function () {
          return {};
        }
      },
      
      _relations: {
        value: function () {
          return {};
        }
      },
      
      _refs: {
        value: function () {
          return [];
        }
      }
    },
    
    get isNew() {
      return !this.path;
    },
    
    get zeroValue() {
      return {};
    },
    
    create: function () {
      this.ref.push(this.preData);
    },
    
    attached: function () {
      for (var tagName in this.parents) {
        this._initializeRelations('parent', this.parents[tagName], tagName);
      }
      
      for (var tagName in this.relationships) {
        this._initializeRelations('relationship', this.relationships[tagName], tagName);
      }
      
      this._initialize();
    },
    
    detached: function () {
      this._unitilialize();
    },
    
    transaction: function () {
      return new VA.Transaction(this.appName);
    },
    
    link: function (target, nonInverse) {
      if (this.linkable(target)) {
        var transaction = this.transaction();
        
        if (this.isParent(target.is)) {
          transaction.push(this.fullRelationPath(target.is), target.key);
        } else if (this.isRelationship(target.is)) {
          transaction.push(this.fullRelationPath(target.is) + '/' + target.key, true);
        }
        
        if (!nonInverse) {
          transaction.merge(target.link(this, true));
        }
        
        return transaction;
      }
    },
    
    unlink: function (target, nonInverse) {
      if (this.linkable(target)) {
        var transaction = this.transaction();
        
        if (this.isParent(target.is)) {
          transaction.push(this.fullRelationPath(target.is), null);
        } else if (this.isRelationship(target.is)) {
          transaction.push(this.fullRelationPath(target.is) + '/' + target.key, null);
        }
        
        if (!nonInverse) {
          transaction.merge(target.unlink(this, true));
        }
        
        return transaction;
      }
    },
    
    remove: function () {
      if (this.key) {
        var promises = [];
        
        for (var tagName in this.relationships) {
          promises.push(new Promise(function (resolve, reject) {
            var ref = this._relation(tagName).orderByModel(this).equalTo(true);
            var root = this.ref.root.toString();
            
            ref.once('value', function (snapshot) {
              var refs = [];
              snapshot.forEach(function (s) {
                //refs.push(s.ref.toString().replace(root, '') + '/' + docPath);
                console.log(s.ref.toString());
              });
              resolve(refs);
            });
          }.bind(this)));
        }
        
        Promise.all(promises).then(function (refs) {
          var transaction = {};
          
          for (var i in refs) {
            for (var j in refs[i]) {
              transaction[refs[i][j]] = null;
            }
          }
          
          transaction[this.path + '/' + this.key] = null;
        }.bind(this));
      }
    },
    
    /**
     * @override
     */
    save: function () {
      this.data = this.preData;
    },
    
    /**
     * @override
     */
    setStoredValue: function (path, value) {
      var keys = Object.getOwnPropertyNames(value);
      
      if (this.key && keys.length > 0) {
        console.log(value, this.key)
        this.ref.child(this.key).set(value);
      }
    },
    
    isParent: function (tagName) {
      return this._relations[tagName].type === 'parent';
    },
    
    isRelationship: function (tagName) {
      return this._relations[tagName].type === 'relationship';
    },
    
    basePath: function () {
      return this.path + '/' + this.key;
    },
    
    relationPath: function (tagName) {
      return this._relations[tagName].path;
    },
    
    fullRelationPath: function (tagName) {
      return this.basePath() + '/' + this.relationPath(tagName);
    },
    
    linkable: function (elem) {
      return this.key && elem.key && elem.is in this._relations;
    },
    
    orderByModel: function (elem) {
      var ref;
      
      if (this.isParent(elem.is)) {
        ref = this.ref.orderByChild(this.relationPath(elem.is));
      } else if (this.isRelationship(elem.is)) {
        ref = this.ref.orderByChild(this.relationPath(elem.is) + '/' + elem.key);
      }
      
      return ref;
    },
    
    _linkedRelationship: function (path, snapshot) {
      this.push(['assocKeys', path], snapshot.key);
    },
    
    _unlinkedRelationship: function (path, snapshot) {
      var index;
      var len = this.assocKeys.path.length;
      for (index = 0; index < len; index++) {
        if (this.assocKeys.path[index] === snapshot.key) {
          break;
        }
      }
      this.splice(['assocKeys', path], index, 1);
    },
    
    _changedParent: function (path, snapshot) {
      this.set(['assocKeys', path], snapshot.val());
    },
    
    _changedData: function (snapshot) {
      this.data = snapshot.val();
    },
    
    _unitilialize: function () {
      this._refs.forEach(function (ref) {
        this.db.ref(ref.path).off(ref.type, ref.callback);
      }.bind(this));
      
      this._refs = [];
      this.assocKeys = {};
      this.data = this.zeroValue;
      this.preData = this.zeroValue;
    },
    
    _refOn: function (type, path, callback) {
      this.db.ref(path).on(type, callback);
      this._refs.push({
        type: type,
        path: path,
        callback: callback
      });
    },
    
    _initialize: function () {
      this._refOn('value', this.basePath(), this._changedData.bind(this));
      
      for (var tagName in this._relations) {
        var rel = this._relations[tagName];
        var path = this.basePath() + '/' + rel.path;
        
        this._resetAssocKeys(rel.type, rel.path);
        
        if (rel.type === 'parent') {
          this._refOn('value', path, this._changedParent.bind(this, rel.path));
        } else if (rel.type === 'relationship') {
          this._refOn('child_added', path, this._linkedRelationship.bind(this, rel.path));
          this._refOn('child_removed', path, this._unlinkedRelationship.bind(this, rel.path));
        }
      }
    },
    
    _keyChanged: function (newKey, oldKey) {
      if (oldKey) {
        this._unitilialize();
        this._initialize();
      }
    },
    
    _relation: function (tagName) {
      var rel = Polymer.dom(this.root).querySelector(tagName);
      
      if (!rel) {
        rel = document.createElement(tagName);
        Polymer.dom(this.root).appendChild(rel);
      }
      
      return rel;
    },
    
    _resetAssocKeys: function (type, path) {
      this.set(['assocKeys', path], type === 'relationship' ? [] : '');
    },
    
    _initializeRelations: function (type, rel, tagName) {
      if (typeof rel === 'string') {
        this._relations[tagName] = {
          type: type,
          path: rel,
          destroy: false,
          vanish: false
        };
      } else {
        this._relations[tagName] = {
          type: type,
          path: rel.path || '',
          destroy: rel.destroy || false,
          vanish: rel.vanish || false
        };
      }
    }
  };
  
  VA.ModelBehavior = [
    Polymer.FirebaseDatabaseBehavior,
    VA.ModelBehaviorImpl
  ];
</script>
